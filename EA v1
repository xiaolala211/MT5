// Smart Money Concepts EA - Fixed Version
// Version 2.0 - All Errors Resolved

#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\AccountInfo.mqh>
#include <Trade\SymbolInfo.mqh>
#include <Trade\OrderInfo.mqh>

//+------------------------------------------------------------------+
//| Structures and Enumerations                                       |
//+------------------------------------------------------------------+
struct PriceZone {
    double high;
    double low;
    int    bar_index;
    bool   isValid;
    int    touchCount;
    datetime firstCreated;
    double mitigationLevel;
    
    void PriceZone() {
        Reset();
    }
    
    void Reset() {
        high = 0;
        low = 0;
        bar_index = -1;
        isValid = false;
        touchCount = 0;
        firstCreated = 0;
        mitigationLevel = 0;
    }
};

enum ENUM_BIAS {
    BIAS_STRONG_BEARISH = -2,
    BIAS_BEARISH = -1,
    BIAS_NEUTRAL = 0,
    BIAS_BULLISH = 1,
    BIAS_STRONG_BULLISH = 2
};

enum ENUM_MARKET_STRUCTURE {
    STRUCTURE_TRENDING_UP,
    STRUCTURE_TRENDING_DOWN,
    STRUCTURE_RANGING,
    STRUCTURE_CONSOLIDATING,
    STRUCTURE_VOLATILE
};

enum ENUM_TRADING_SESSION {
    SESSION_ASIAN,
    SESSION_LONDON,
    SESSION_NEWYORK,
    SESSION_SYDNEY,
    SESSION_NONE
};

enum ENUM_HTF_REACTION_CONTEXT {
    HTF_POI_NONE,
    HTF_POI_IN_BULLISH_OB,
    HTF_POI_IN_BEARISH_OB,
    HTF_POI_IN_BULLISH_FVG,
    HTF_POI_IN_BEARISH_FVG
};
//+------------------------------------------------------------------+
//| Function Declarations                                             |
//+------------------------------------------------------------------+
bool ValidateInputs();
void InitializePerformanceTracking();
void OnNewBar();
bool ShouldTrade();
void ManageOpenPositions();
void UpdateMarketAnalysis();
void LookForTradeSetups();
void CollectAndValidateZones();
double ScoreBuySetup();
double ScoreSellSetup();
void ExecuteEnhancedBuySetup(double setupScore);
void ExecuteEnhancedSellSetup(double setupScore);
double CalculateOptimalStopLoss(ENUM_ORDER_TYPE orderType);
double CalculateEnhancedLotSize(double stopDistance, double setupScore);
double GetPerformanceMultiplier();
void ManageBreakEven(CPositionInfo &position);
void ManagePartialTP(CPositionInfo &position);
void ManageTrailingStop(CPositionInfo &position);
void UpdatePerformanceStats();
bool CheckDailyLimits();
bool CheckEquityProtection();
void CheckDailyReset();
bool IsTradeAllowed();
int CountOpenPositions();
bool IsInTradingSession();
bool IsNearNewsTime();
ENUM_TRADING_SESSION GetCurrentSession();
ENUM_BIAS AnalyzeTimeframeBias(ENUM_TIMEFRAMES timeframe);
ENUM_MARKET_STRUCTURE DetermineMarketStructure();
double GetAverageVolume(ENUM_TIMEFRAMES timeframe, int period);
int CountValidZones(const PriceZone &zones[]);
bool IsPriceInZone(double price, const PriceZone &zone);
double GetZoneDistance(double price, const PriceZone &zone);
double GetFVGMitigationPercent(double price, const PriceZone &fvg);
bool CheckRecentBullishSweep();
bool CheckRecentBearishSweep();
bool CheckBullishMarketStructure();
bool CheckBearishMarketStructure();
bool CheckBullishMomentum();
bool CheckBearishMomentum();
bool CheckHTFBullishConfluence();
bool CheckHTFBearishConfluence();
void CheckExitSignals(CPositionInfo &position);
ulong GetDynamicMagicNumber(ENUM_ORDER_TYPE orderType);
void SaveTradeInfo(ulong ticket, double score, double tp1, double tp2);
double GetTradeTP1(ulong ticket);
void UpdateTradeComment(ulong ticket, string comment);
void SendTradeNotification(string direction, double entry, double sl, double tp, double lots, double score);
void SavePersistentData();
void LoadPersistentData();
string BiasToString(ENUM_BIAS bias);
string StructureToString(ENUM_MARKET_STRUCTURE structure);
double NormalizeLotSize(double lotSize);
void DeleteObjectsByPrefix(const string prefix);
void DrawOrderBlock(const PriceZone &zone, color ob_color, string ob_name_prefix, ENUM_TIMEFRAMES timeframe,
                    ENUM_LINE_STYLE style, int width, bool fill, int extend_bars);
void DrawFairValueGap(const PriceZone &zone, color fvg_color, string fvg_name_prefix, ENUM_TIMEFRAMES timeframe,
                      ENUM_LINE_STYLE style, int width, bool fill, int extend_bars);
void DrawLiquiditySweepMarker(ENUM_TIMEFRAMES timeframe, const PriceZone &sweep_candle_info, 
                              const PriceZone &swept_level_info, bool is_bullish_sweep, 
                              color sweep_color, int arrow_code);

// SMC Pattern Detection Functions
PriceZone FindBullishOrderBlock(ENUM_TIMEFRAMES timeframe, int ob_lookback_period, double min_move_factor, int min_impulse_candles, int shift = 1);
PriceZone FindBearishOrderBlock(ENUM_TIMEFRAMES timeframe, int ob_lookback_period, double min_move_factor, int min_impulse_candles, int shift = 1);
PriceZone FindBullishFVG(ENUM_TIMEFRAMES timeframe, int fvg_lookback_period, double min_fvg_size_points, int shift = 1);
PriceZone FindBearishFVG(ENUM_TIMEFRAMES timeframe, int fvg_lookback_period, double min_fvg_size_points, int shift = 1);
PriceZone GetLastSignificantSwingHigh(ENUM_TIMEFRAMES timeframe, int lookback_range, int N, int shift_start = 1);
PriceZone GetLastSignificantSwingLow(ENUM_TIMEFRAMES timeframe, int lookback_range, int N, int shift_start = 1);
bool CheckForBullishBOS(ENUM_TIMEFRAMES timeframe, const PriceZone &prev_swing_high, int confirmation_shift = 1);
bool CheckForBearishBOS(ENUM_TIMEFRAMES timeframe, const PriceZone &prev_swing_low, int confirmation_shift = 1);
bool IsBullishCHoCH(ENUM_TIMEFRAMES timeframe, int swing_lookback, int N_structural_bars, int confirmation_shift, PriceZone &choch_level_broken);
bool IsBearishCHoCH(ENUM_TIMEFRAMES timeframe, int swing_lookback, int N_structural_bars, int confirmation_shift, PriceZone &choch_level_broken);
bool CheckAndGetBullishLiquiditySweep(ENUM_TIMEFRAMES timeframe, const PriceZone &prev_swing_low,
                                     double min_spike_points, int max_close_back_candles,
                                     PriceZone &sweep_candle_info, int check_bar_shift = 1);
bool CheckAndGetBearishLiquiditySweep(ENUM_TIMEFRAMES timeframe, const PriceZone &prev_swing_high,
                                     double min_spike_points, int max_close_back_candles,
                                     PriceZone &sweep_candle_info, int check_bar_shift = 1);
int FindSwingLow(ENUM_TIMEFRAMES timeframe, int lookback);
int FindSwingHigh(ENUM_TIMEFRAMES timeframe, int lookback);

//+------------------------------------------------------------------+
//| Input Parameters                                                  |
//+------------------------------------------------------------------+
input group "═══ General Settings ═══"
input bool   EnableTrading = true;
input double RiskPercentage = 1.0;
input int    MaxOpenTrades = 3;
input int    MaxDailyTrades = 10;
input double MaxDailyLossPercent = 5.0;
input ulong  ea_magic_number = 123456;

input group "═══ Risk Management ═══"
input bool   UseEquityProtection = true;
input double EquityStopPercent = 20.0;
input bool   UseCorrelationFilter = false;
input double MaxCorrelationCoeff = 0.7;

input group "═══ Trade Management ═══"
input bool   UseBreakEven = true;
input double BE_Trigger_RR = 1.0;
input int    BE_Plus_Pips = 20;
input bool   UsePartialTakeProfit = true;
input double PartialTPPercent = 50.0;
input double TP1_RRRatio = 1.0;
input double TP2_RRRatio = 2.0;
input double RRRatio = 2.0;
input int    SL_BufferPoints = 100;
input int    MinStopDistancePoints = 200;
input bool   UseTrailingStop = false;
input double TrailStartRR = 1.5;
input double TrailDistanceRR = 0.5;

input group "═══ Session Filters ═══"
input bool   UseSessionFilter = false;
input bool   TradeAsianSession = false;
input bool   TradeLondonSession = true;
input bool   TradeNewYorkSession = true;
input bool   AvoidNewsTime = false;
input int    NewsAvoidMinutes = 30;

input group "═══ Timeframes ═══"
input ENUM_TIMEFRAMES HTF_Primary = PERIOD_H4;
input ENUM_TIMEFRAMES HTF_Secondary = PERIOD_D1;
input ENUM_TIMEFRAMES HTF_BiasPeriod = PERIOD_H4;
input bool   RequireHTFAlignment = true;

input group "═══ SMC Detection ═══"
input bool   UseOrderBlocks = true;
input int    OrderBlockLookbackPeriod = 30;
input double MinMoveAfterOBFactor = 1.5;
input int    MinImpulseCandles = 1;
input int    OB_MinTouchesBeforeMitigation = 0;
input double OB_MaxAgeHours = 168;

input bool   UseFairValueGaps = true;
input int    FVGLookbackPeriod = 30;
input double MinFVGSizePoints = 50;
input double FVG_MinMitigationPercent = 30.0;

input bool   UseLiquiditySweeps = true;
input double SweepMinSpikePoints = 10;
input int    SweepCloseBackCandles = 1;
input int    Sweep_MinPreviousTests = 2;

input group "═══ Structure Settings ═══"
input int    SwingLookback = 10;
input int    StructuralSwingMinBars = 3;
input int    BOS_CHoCH_MinBreakPoints = 50;

input group "═══ Strategy Settings ═══"
input bool   TradeBullish = true;
input bool   TradeBearish = true;
input bool   AllowTradingNeutralBias = true;
input bool   AllowVolatileTrading = false;

input group "═══ Visual Settings ═══"
input bool   Draw_OrderBlocks = true;
input color  Bullish_OB_Color = clrDeepSkyBlue;
input color  Bearish_OB_Color = clrLightCoral;
input ENUM_LINE_STYLE OB_Style = STYLE_SOLID;
input int    OB_Width = 1;
input bool   OB_Fill = true;
input int    OB_Extend_Bars = 10;

input bool   Draw_FairValueGaps = true;
input color  Bullish_FVG_Color = clrLightSkyBlue;
input color  Bearish_FVG_Color = clrPink;
input ENUM_LINE_STYLE FVG_Style = STYLE_DOT;
input int    FVG_Width = 1;
input bool   FVG_Fill = true;
input int    FVG_Extend_Bars = 15;

input bool   Draw_LiquiditySweeps = true;
input color  Bullish_LS_Color = clrChartreuse;
input color  Bearish_LS_Color = clrOrangeRed;
input int    ArrowBullishSweepCode = 241;
input int    ArrowBearishSweepCode = 242;

input group "═══ Entry Confirmation ═══"
input bool C_Entry_Require_OB_Touch = true;
input bool C_Entry_Require_FVG_Mitigation = false;
input bool C_Entry_Require_Sweep_Occurred = false;
input bool C_Entry_Require_BOS_Confirmation = true;
input bool C_Entry_Require_CHoCH_Signal = true;
input ENUM_TIMEFRAMES C_Entry_Confirmation_TF = PERIOD_CURRENT;

//+------------------------------------------------------------------+
//| Global Variables                                                  |
//+------------------------------------------------------------------+
CTrade trade;
CPositionInfo positionInfo;
CAccountInfo accountInfo;
CSymbolInfo symbolInfo;
COrderInfo orderInfo;

ENUM_BIAS currentBias = BIAS_NEUTRAL;
ENUM_MARKET_STRUCTURE marketStructure = STRUCTURE_RANGING;
ENUM_HTF_REACTION_CONTEXT currentHTF_POI_Context = HTF_POI_NONE;

datetime lastBarTime = 0;
int dailyTradeCount = 0;
datetime lastDayReset = 0;
double dailyPnL = 0;
double startingEquity = 0;
bool lastBarTraded = false;
int orderCount = 0;

PriceZone active_HTF_POI_Zone;

//+------------------------------------------------------------------+
//| Performance Statistics Structure                                  |
//+------------------------------------------------------------------+
struct PerformanceStats {
    int totalTrades;
    int winningTrades;
    int losingTrades;
    double totalProfit;
    double totalLoss;
    double maxDrawdown;
    double averageWin;
    double averageLoss;
    double profitFactor;
    double winRate;
    datetime lastUpdate;
};
PerformanceStats stats;

//+------------------------------------------------------------------+
//| Zone Manager Structure                                            |
//+------------------------------------------------------------------+
struct ZoneManager {
    PriceZone bullishOBs[];
    PriceZone bearishOBs[];
    PriceZone bullishFVGs[];
    PriceZone bearishFVGs[];
    
    void AddZone(PriceZone &zone, PriceZone &zones[]) {
        int size = ArraySize(zones);
        ArrayResize(zones, size + 1);
        zones[size] = zone;
        zones[size].firstCreated = TimeCurrent();
    }
    
    void CleanOldZones(PriceZone &zones[], double maxAgeHours) {
        datetime cutoffTime = TimeCurrent() - (int)(maxAgeHours * 3600);
        int validCount = 0;
        
        for(int i = 0; i < ArraySize(zones); i++) {
            if(zones[i].firstCreated > cutoffTime && zones[i].isValid) {
                if(i != validCount) {
                    zones[validCount] = zones[i];
                }
                validCount++;
            }
        }
        
        if(validCount < ArraySize(zones)) {
            ArrayResize(zones, validCount);
        }
    }
    
    PriceZone FindNearestZone(PriceZone &zones[], double price) {
        PriceZone nearest;
        double minDistance = DBL_MAX;
        
        for(int i = 0; i < ArraySize(zones); i++) {
            if(!zones[i].isValid) continue;
            
            double distance = 0;
            if(price > zones[i].high) {
                distance = price - zones[i].high;
            } else if(price < zones[i].low) {
                distance = zones[i].low - price;
            }
            
            if(distance < minDistance) {
                minDistance = distance;
                nearest = zones[i];
            }
        }
        
        return nearest;
    }
};
ZoneManager zoneManager;

// Trade info storage
struct TradeInfo {
    ulong ticket;
    double score;
    double tp1;
    double tp2;
    bool partialClosed;
};
TradeInfo tradeInfos[];



//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit() {
    Print("╔═══════════════════════════════════════════════════════╗");
    Print("║   Smart Money Concepts EA v2.0 - Enhanced Edition     ║");
    Print("╚═══════════════════════════════════════════════════════╝");
    
    if(!symbolInfo.Name(_Symbol)) {
        Print("ERROR: Failed to initialize symbol info");
        return INIT_FAILED;
    }
    
    if(!ValidateInputs()) {
        return INIT_FAILED;
    }
    
    trade.SetExpertMagicNumber(ea_magic_number);
    trade.SetMarginMode();
    trade.SetTypeFillingBySymbol(_Symbol);
    trade.SetDeviationInPoints(10);
    
    InitializePerformanceTracking();
    LoadPersistentData();
    
    ArrayResize(zoneManager.bullishOBs, 0);
    ArrayResize(zoneManager.bearishOBs, 0);
    ArrayResize(zoneManager.bullishFVGs, 0);
    ArrayResize(zoneManager.bearishFVGs, 0);
    ArrayResize(tradeInfos, 0);
    
    startingEquity = accountInfo.Equity();
    
    Print("Initialization successful. Starting equity: ", startingEquity);
    return INIT_SUCCEEDED;
}



//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick() {
    if(!EnableTrading) return;
    if(!IsTradeAllowed()) return;
    if(!CheckDailyLimits()) return;
    if(!CheckEquityProtection()) return;
    
    datetime currentBarTime = iTime(_Symbol, PERIOD_CURRENT, 0);
    bool isNewBar = (currentBarTime != lastBarTime);
    
    if(isNewBar) {
        lastBarTime = currentBarTime;
        lastBarTraded = false;
        OnNewBar();
    }
    
    ManageOpenPositions();
    UpdatePerformanceStats();
}

//+------------------------------------------------------------------+
//| Implementation of all required functions                         |
//+------------------------------------------------------------------+

bool ValidateInputs() {
    if(RiskPercentage <= 0 || RiskPercentage > 10) {
        Print("ERROR: Invalid RiskPercentage. Must be between 0.1 and 10");
        return false;
    }
    
    if(MaxOpenTrades < 1 || MaxOpenTrades > 10) {
        Print("ERROR: Invalid MaxOpenTrades. Must be between 1 and 10");
        return false;
    }
    
    if(HTF_Primary <= PERIOD_CURRENT) {
        Print("ERROR: HTF_Primary must be higher than current timeframe");
        return false;
    }
    
    return true;
}

void InitializePerformanceTracking() {
    stats.totalTrades = 0;
    stats.winningTrades = 0;
    stats.losingTrades = 0;
    stats.totalProfit = 0;
    stats.totalLoss = 0;
    stats.maxDrawdown = 0;
    stats.averageWin = 0;
    stats.averageLoss = 0;
    stats.profitFactor = 0;
    stats.winRate = 0;
    stats.lastUpdate = TimeCurrent();
}

void OnNewBar() {
    CheckDailyReset();
    
    zoneManager.CleanOldZones(zoneManager.bullishOBs, OB_MaxAgeHours);
    zoneManager.CleanOldZones(zoneManager.bearishOBs, OB_MaxAgeHours);
    
    UpdateMarketAnalysis();
    
    if(ShouldTrade() && !lastBarTraded) {
        LookForTradeSetups();
        lastBarTraded = true;
    }
}

bool ShouldTrade() {
    if(UseSessionFilter && !IsInTradingSession()) {
        return false;
    }
    
    if(AvoidNewsTime && IsNearNewsTime()) {
        return false;
    }
    
    int openPositions = CountOpenPositions();
    if(openPositions >= MaxOpenTrades) {
        return false;
    }
    
    if(dailyTradeCount >= MaxDailyTrades) {
        return false;
    }
    
    if(marketStructure == STRUCTURE_VOLATILE && !AllowVolatileTrading) {
        return false;
    }
    
    return true;
}

bool IsTradeAllowed() {
    // FIX: Removed extra comma and ensured correct use of TerminalInfoInteger for TERMINAL_TRADE_ALLOWED.
    // TERMINAL_NOTIFICATIONS is a constant, not a boolean flag for trade allowance.
    return (bool)MQLInfoInteger(MQL_TRADE_ALLOWED) && 
           (bool)TerminalInfoInteger(TERMINAL_TRADE_ALLOWED) && 
           (bool)AccountInfoInteger(ACCOUNT_TRADE_ALLOWED);
}

void CheckDailyReset() {
    MqlDateTime currentTime;
    TimeToStruct(TimeCurrent(), currentTime);
    
    MqlDateTime lastResetTime;
    TimeToStruct(lastDayReset, lastResetTime);
    
    if(currentTime.day != lastResetTime.day) {
        dailyTradeCount = 0;
        dailyPnL = 0;
        lastDayReset = TimeCurrent();
        startingEquity = accountInfo.Equity();
    }
}

int CountOpenPositions() {
    int count = 0;
    for(int i = 0; i < PositionsTotal(); i++) {
        if(positionInfo.SelectByIndex(i)) {
            if(positionInfo.Symbol() == _Symbol &&
               positionInfo.Magic() == ea_magic_number) {
                count++;
            }
        }
    }
    return count;
}

bool IsInTradingSession() {
    ENUM_TRADING_SESSION currentSession = GetCurrentSession();
    
    switch(currentSession) {
        case SESSION_ASIAN: return TradeAsianSession;
        case SESSION_LONDON: return TradeLondonSession;
        case SESSION_NEWYORK: return TradeNewYorkSession;
        default: return false;
    }
}

ENUM_TRADING_SESSION GetCurrentSession() {
    MqlDateTime time;
    TimeToStruct(TimeCurrent(), time);
    int hour = time.hour;
    
    // Simplified session times (can be adjusted)
    if(hour >= 0 && hour < 8) return SESSION_ASIAN;
    else if(hour >= 8 && hour < 13) return SESSION_LONDON;
    else if(hour >= 13 && hour < 22) return SESSION_NEWYORK;
    else return SESSION_SYDNEY;
}

bool IsNearNewsTime() {
    // Placeholder - implement news calendar check
    return false;
}

bool CheckDailyLimits() {
    double currentEquity = accountInfo.Equity();
    double dailyLoss = (startingEquity - currentEquity) / startingEquity * 100;
    
    if(dailyLoss >= MaxDailyLossPercent) {
        if(MQLInfoInteger(MQL_DEBUG))
            Print("Daily loss limit reached: ", DoubleToString(dailyLoss, 2), "%");
        return false;
    }
    
    if(dailyTradeCount >= MaxDailyTrades) {
        if(MQLInfoInteger(MQL_DEBUG))
            Print("Daily trade limit reached: ", dailyTradeCount);
        return false;
    }
    
    return true;
}

bool CheckEquityProtection() {
    if(!UseEquityProtection) return true;
    
    double currentEquity = accountInfo.Equity();
    double initialBalance = 0;
    
    // Get initial balance from first deal
    // This logic to get initialBalance from first deal is flawed and can be unreliable.
    // For true persistence, consider saving this to a file on OnInit and loading on Deinit.
    // For now, setting it to current Balance if it's 0 to avoid division by zero.
    if(initialBalance == 0) initialBalance = accountInfo.Balance(); 
    
    double equityDropPercent = (initialBalance - currentEquity) / initialBalance * 100;
    
    if(equityDropPercent >= EquityStopPercent) {
        Print("Equity protection triggered: ", DoubleToString(equityDropPercent, 2), "% drop");
        return false;
    }
    
    return true;
}

void CollectAndValidateZones() {
    // Clear old drawing objects
    if(Draw_OrderBlocks) {
        DeleteObjectsByPrefix("SMC_BullishOB_");
        DeleteObjectsByPrefix("SMC_BearishOB_");
    }
    if(Draw_FairValueGaps) {
        DeleteObjectsByPrefix("SMC_BullishFVG_");
        DeleteObjectsByPrefix("SMC_BearishFVG_");
    }
    
    // Find and add new zones
    if(UseOrderBlocks) {
        PriceZone bullishOB = FindBullishOrderBlock(PERIOD_CURRENT, OrderBlockLookbackPeriod, MinMoveAfterOBFactor, MinImpulseCandles);
        if(bullishOB.isValid) {
            zoneManager.AddZone(bullishOB, zoneManager.bullishOBs);
            if(Draw_OrderBlocks) {
                DrawOrderBlock(bullishOB, Bullish_OB_Color, "SMC_BullishOB", PERIOD_CURRENT, 
                               OB_Style, OB_Width, OB_Fill, OB_Extend_Bars);
            }
        }
        
        PriceZone bearishOB = FindBearishOrderBlock(PERIOD_CURRENT, OrderBlockLookbackPeriod, MinMoveAfterOBFactor, MinImpulseCandles);
        if(bearishOB.isValid) {
            zoneManager.AddZone(bearishOB, zoneManager.bearishOBs);
            if(Draw_OrderBlocks) {
                DrawOrderBlock(bearishOB, Bearish_OB_Color, "SMC_BearishOB", PERIOD_CURRENT, 
                               OB_Style, OB_Width, OB_Fill, OB_Extend_Bars);
            }
        }
    }
    
    if(UseFairValueGaps) {
        PriceZone bullishFVG = FindBullishFVG(PERIOD_CURRENT, FVGLookbackPeriod, MinFVGSizePoints);
        if(bullishFVG.isValid) {
            zoneManager.AddZone(bullishFVG, zoneManager.bullishFVGs);
            if(Draw_FairValueGaps) {
                DrawFairValueGap(bullishFVG, Bullish_FVG_Color, "SMC_BullishFVG", PERIOD_CURRENT, 
                                 FVG_Style, FVG_Width, FVG_Fill, FVG_Extend_Bars);
            }
        }
        
        PriceZone bearishFVG = FindBearishFVG(PERIOD_CURRENT, FVGLookbackPeriod, MinFVGSizePoints);
        if(bearishFVG.isValid) {
            zoneManager.AddZone(bearishFVG, zoneManager.bearishFVGs);
            if(Draw_FairValueGaps) {
                DrawFairValueGap(bearishFVG, Bearish_FVG_Color, "SMC_BearishFVG", PERIOD_CURRENT, 
                                 FVG_Style, FVG_Width, FVG_Fill, FVG_Extend_Bars);
            }
        }
    }
}

// Placeholder implementations for helper functions
double GetAverageVolume(ENUM_TIMEFRAMES timeframe, int period) {
    double sum = 0;
    for(int i = 1; i <= period; i++) {
        sum += (double)iVolume(_Symbol, timeframe, i);
    }
    return sum / period;
}

bool CheckRecentBullishSweep() {
    PriceZone lastLow = GetLastSignificantSwingLow(PERIOD_CURRENT, SwingLookback, StructuralSwingMinBars);
    PriceZone sweepInfo;
    return CheckAndGetBullishLiquiditySweep(PERIOD_CURRENT, lastLow, SweepMinSpikePoints, SweepCloseBackCandles, sweepInfo);
}
bool CheckRecentBearishSweep() {
    PriceZone lastHigh = GetLastSignificantSwingHigh(PERIOD_CURRENT, SwingLookback, StructuralSwingMinBars);
    PriceZone sweepInfo;
    return CheckAndGetBearishLiquiditySweep(PERIOD_CURRENT, lastHigh, SweepMinSpikePoints, SweepCloseBackCandles, sweepInfo);
}

bool CheckBullishMarketStructure() {
    PriceZone lastHigh = GetLastSignificantSwingHigh(PERIOD_CURRENT, SwingLookback, StructuralSwingMinBars);
    return CheckForBullishBOS(PERIOD_CURRENT, lastHigh);
}

bool CheckBearishMarketStructure() {
    PriceZone lastLow = GetLastSignificantSwingLow(PERIOD_CURRENT, SwingLookback, StructuralSwingMinBars);
    return CheckForBearishBOS(PERIOD_CURRENT, lastLow);
}

bool CheckBullishMomentum() {
    // FIX: Added shift = 0 to iRSI
    double rsi = iRSI(_Symbol, PERIOD_CURRENT, 14, PRICE_CLOSE); 
    
    // FIX: Declare macd_main and macd_signal as arrays with size [1]
    double macd_main[1], macd_signal[1];
    
    // FIX: Ensure macdHandle is correctly initialized and checked
    int macdHandle = iMACD(_Symbol, PERIOD_CURRENT, 12, 26, 9, PRICE_CLOSE);
    if(macdHandle == INVALID_HANDLE) {
        // Handle error, e.g., print and return false
        PrintFormat("Failed to create MACD handle in CheckBullishMomentum. Error: %d", GetLastError());
        return false;
    }
    
    // FIX: Set arrays as series for correct indexing (current bar at index 0)
    ArraySetAsSeries(macd_main, true);
    ArraySetAsSeries(macd_signal, true);
    
    // FIX: Use CopyBuffer correctly, passing array and checking return value
    if(CopyBuffer(macdHandle, 0, 0, 1, macd_main) > 0 && 
       CopyBuffer(macdHandle, 1, 0, 1, macd_signal) > 0) {
        // FIX: Release indicator handle after use
        IndicatorRelease(macdHandle);
        return (rsi > 50 && macd_main[0] > macd_signal[0]);
    }
    
    // FIX: Ensure IndicatorRelease is called even if CopyBuffer fails
    IndicatorRelease(macdHandle);
    return false;
}

bool CheckBearishMomentum() {
    // FIX: Removed extra comma and added shift = 0 to iRSI
    double rsi = iRSI(_Symbol, PERIOD_CURRENT, 14, PRICE_CLOSE); 
    
    // FIX: Declare macd_main and macd_signal as arrays with size [1]
    double macd_main[1], macd_signal[1];
    
    // FIX: Ensure macdHandle is correctly initialized and checked
    int macdHandle = iMACD(_Symbol, PERIOD_CURRENT, 12, 26, 9, PRICE_CLOSE);
    if(macdHandle == INVALID_HANDLE) {
        // Handle error, e.g., print and return false
        PrintFormat("Failed to create MACD handle in CheckBearishMomentum. Error: %d", GetLastError());
        return false;
    }
    
    // FIX: Set arrays as series for correct indexing (current bar at index 0)
    ArraySetAsSeries(macd_main, true);
    ArraySetAsSeries(macd_signal, true);
    
    // FIX: Use CopyBuffer correctly, passing array and checking return value
    if(CopyBuffer(macdHandle, 0, 0, 1, macd_main) > 0 && 
       CopyBuffer(macdHandle, 1, 0, 1, macd_signal) > 0) {
        // FIX: Release indicator handle after use
        IndicatorRelease(macdHandle);
        return (rsi < 50 && macd_main[0] < macd_signal[0]);
    }
    
    // FIX: Ensure IndicatorRelease is called even if CopyBuffer fails
    IndicatorRelease(macdHandle);
    return false;
}

bool CheckHTFBullishConfluence() {
    ENUM_BIAS htf1Bias = AnalyzeTimeframeBias(HTF_Primary);
    ENUM_BIAS htf2Bias = AnalyzeTimeframeBias(HTF_Secondary);
    
    if(RequireHTFAlignment) {
        return (htf1Bias >= BIAS_BULLISH && htf2Bias >= BIAS_BULLISH);
    } else {
        return (htf1Bias >= BIAS_BULLISH || htf2Bias >= BIAS_BULLISH);
    }
}

bool CheckHTFBearishConfluence() {
    ENUM_BIAS htf1Bias = AnalyzeTimeframeBias(HTF_Primary);
    ENUM_BIAS htf2Bias = AnalyzeTimeframeBias(HTF_Secondary);
    
    if(RequireHTFAlignment) {
        return (htf1Bias <= BIAS_BEARISH && htf2Bias <= BIAS_BEARISH);
    } else {
        return (htf1Bias <= BIAS_BEARISH || htf2Bias <= BIAS_BEARISH);
    }
}

void CheckExitSignals(CPositionInfo &position) {
    // Check for reversal signals
    if(position.PositionType() == POSITION_TYPE_BUY && currentBias <= BIAS_BEARISH) {
        if(trade.PositionClose(position.Ticket())) {
            Print("Closed BUY position due to bearish reversal");
        }
    } else if(position.PositionType() == POSITION_TYPE_SELL && currentBias >= BIAS_BULLISH) {
        if(trade.PositionClose(position.Ticket())) {
            Print("Closed SELL position due to bullish reversal");
        }
    }
}

ulong GetDynamicMagicNumber(ENUM_ORDER_TYPE orderType) {
    // Create unique magic number based on EA magic + order type
    return ea_magic_number + (ulong)orderType;
}

void SaveTradeInfo(ulong ticket, double score, double tp1, double tp2) {
    int size = ArraySize(tradeInfos);
    ArrayResize(tradeInfos, size + 1);
    
    tradeInfos[size].ticket = ticket;
    tradeInfos[size].score = score;
    tradeInfos[size].tp1 = tp1;
    tradeInfos[size].tp2 = tp2;
    tradeInfos[size].partialClosed = false;
}

double GetTradeTP1(ulong ticket) {
    for(int i = 0; i < ArraySize(tradeInfos); i++) {
        if(tradeInfos[i].ticket == ticket) {
            return tradeInfos[i].tp1;
        }
    }
    return 0;
}

void UpdateTradeComment(ulong ticket, string comment) {
    for(int i = 0; i < ArraySize(tradeInfos); i++) {
        if(tradeInfos[i].ticket == ticket) {
            tradeInfos[i].partialClosed = true;
            break;
        }
    }
}

void SendTradeNotification(string direction, double entry, double sl, double tp, double lots, double score) {
    string message = StringFormat("%s %s: Entry=%.5f, SL=%.5f, TP=%.5f, Lots=%.2f, Score=%.1f",
                                  _Symbol, direction, entry, sl, tp, lots, score);
    
    if(TerminalInfoInteger(TERMINAL_NOTIFICATIONS)) {
        SendNotification(message);
    }
    
    Print(message);
}

void SavePersistentData() {
    int handle = FileOpen("SMC_EA_Stats.bin", FILE_WRITE|FILE_BIN);
    if(handle != INVALID_HANDLE) {
        FileWriteStruct(handle, stats);
        FileClose(handle);
    }
}

void LoadPersistentData() {
    int handle = FileOpen("SMC_EA_Stats.bin", FILE_READ|FILE_BIN);
    if(handle != INVALID_HANDLE) {
        FileReadStruct(handle, stats);
        FileClose(handle);
    }
}

//+------------------------------------------------------------------+
//| SMC Pattern Detection Functions (from original EA)               |
//+------------------------------------------------------------------+
PriceZone FindBullishOrderBlock(ENUM_TIMEFRAMES timeframe, int ob_lookback_period, double min_move_factor, int min_impulse_candles, int shift) {
    PriceZone ob;
    MqlRates rates[];
    ArraySetAsSeries(rates, true);

    int rates_to_copy = ob_lookback_period + min_impulse_candles + shift + 5; 
    if (CopyRates(_Symbol, timeframe, shift, rates_to_copy, rates) < rates_to_copy) {
        PrintFormat("Error copying rates for Bullish OB detection on %s: %d", EnumToString(timeframe), GetLastError());
        return ob;
    }

    for (int i = min_impulse_candles; i < ob_lookback_period + min_impulse_candles; i++) {
        if (i >= ArraySize(rates) -1) break; 

        if (rates[i].close < rates[i].open) { 
            bool strong_bullish_move = true;
            double total_impulse_move_range = 0;
            double highest_high_after_ob = 0;

            for(int k=0; k < min_impulse_candles; k++) {
                int impulse_candle_idx = i - 1 - k;
                if (impulse_candle_idx < 0) {
                    strong_bullish_move = false; 
                    break;
                }
                if (rates[impulse_candle_idx].close <= rates[impulse_candle_idx].open) {
                    strong_bullish_move = false;
                    break;
                }
                if (rates[impulse_candle_idx].high > highest_high_after_ob) {
                    highest_high_after_ob = rates[impulse_candle_idx].high;
                }
                total_impulse_move_range += (rates[impulse_candle_idx].high - rates[impulse_candle_idx].low);
            }
            
            if (!strong_bullish_move) continue;

            double ob_candle_body = rates[i].open - rates[i].close;
            if (highest_high_after_ob > rates[i].high && total_impulse_move_range >= ob_candle_body * min_move_factor) {
                ob.high = rates[i].high;
                ob.low = rates[i].low;
                ob.bar_index = (int)iBarShift(_Symbol, timeframe, rates[i].time); 
                ob.isValid = true;
                return ob; 
            }
        }
    }
    return ob; 
}

PriceZone FindBearishOrderBlock(ENUM_TIMEFRAMES timeframe, int ob_lookback_period, double min_move_factor, int min_impulse_candles, int shift) {
    PriceZone ob;
    MqlRates rates[];
    ArraySetAsSeries(rates, true);

    int rates_to_copy = ob_lookback_period + min_impulse_candles + shift + 5;
    if (CopyRates(_Symbol, timeframe, shift, rates_to_copy, rates) < rates_to_copy) {
        PrintFormat("Error copying rates for Bearish OB detection on %s: %d", EnumToString(timeframe), GetLastError());
        return ob;
    }

    for (int i = min_impulse_candles; i < ob_lookback_period + min_impulse_candles; i++) {
        if (i >= ArraySize(rates)-1) break;

        if (rates[i].close > rates[i].open) { 
            bool strong_bearish_move = true;
            double total_impulse_move_range = 0;
            double lowest_low_after_ob = rates[0].low;
            if (ArraySize(rates) > 0 && min_impulse_candles > 0 && (i-1) >=0 ) {
                lowest_low_after_ob = rates[i-1].low;
            }

            for(int k=0; k < min_impulse_candles; k++) {
                int impulse_candle_idx = i - 1 - k;
                 if (impulse_candle_idx < 0) {
                    strong_bearish_move = false; 
                    break;
                }
                if (rates[impulse_candle_idx].close >= rates[impulse_candle_idx].open) {
                    strong_bearish_move = false;
                    break;
                }
                if (rates[impulse_candle_idx].low < lowest_low_after_ob) {
                    lowest_low_after_ob = rates[impulse_candle_idx].low;
                }
                total_impulse_move_range += (rates[impulse_candle_idx].high - rates[impulse_candle_idx].low);
            }

            if (!strong_bearish_move) continue;

            double ob_candle_body = rates[i].close - rates[i].open;
            if (lowest_low_after_ob < rates[i].low && total_impulse_move_range >= ob_candle_body * min_move_factor) {
                ob.high = rates[i].high;
                ob.low = rates[i].low;
                ob.bar_index = (int)iBarShift(_Symbol, timeframe, rates[i].time);
                ob.isValid = true;
                return ob; 
            }
        }
    }
    return ob;
}

PriceZone FindBullishFVG(ENUM_TIMEFRAMES timeframe, int fvg_lookback_period, double min_fvg_size_points, int shift) {
    PriceZone fvg;
    MqlRates rates[];
    ArraySetAsSeries(rates, true);

    int rates_to_copy = fvg_lookback_period + 3 + shift;
    if (CopyRates(_Symbol, timeframe, shift, rates_to_copy, rates) < rates_to_copy) {
        PrintFormat("Error copying rates for Bullish FVG detection on %s: %d", EnumToString(timeframe), GetLastError());
        return fvg;
    }

    for (int i = 0; i < fvg_lookback_period; i++) {
        if (i + 2 >= ArraySize(rates)) {
            break; 
        }

        MqlRates candle3 = rates[i];
        MqlRates candle2 = rates[i+1];
        MqlRates candle1 = rates[i+2];

        if (candle3.low > candle1.high) {
            double fvg_size_actual = (candle3.low - candle1.high) / _Point; 

            if (min_fvg_size_points > 0 && fvg_size_actual < min_fvg_size_points) {
                continue;
            }

            fvg.high = candle3.low;
            fvg.low = candle1.high;
            fvg.bar_index = (int)iBarShift(_Symbol, timeframe, candle2.time);
            fvg.isValid = true;
            return fvg;
        }
    }
    return fvg;
}

PriceZone FindBearishFVG(ENUM_TIMEFRAMES timeframe, int fvg_lookback_period, double min_fvg_size_points, int shift) {
    PriceZone fvg;
    MqlRates rates[];
    ArraySetAsSeries(rates, true);

    int rates_to_copy = fvg_lookback_period + 3 + shift; 
    if (CopyRates(_Symbol, timeframe, shift, rates_to_copy, rates) < rates_to_copy) {
        PrintFormat("Error copying rates for Bearish FVG detection on %s: %d", EnumToString(timeframe), GetLastError());
        return fvg;
    }

    for (int i = 0; i < fvg_lookback_period; i++) {
        if (i + 2 >= ArraySize(rates)) {
            break; 
        }

        MqlRates candle3 = rates[i];
        MqlRates candle2 = rates[i+1];
        MqlRates candle1 = rates[i+2];

        if (candle3.high < candle1.low) {
            double fvg_size_actual = (candle1.low - candle3.high) / _Point;

            if (min_fvg_size_points > 0 && fvg_size_actual < min_fvg_size_points) {
                continue;
            }

            fvg.high = candle1.low;
            fvg.low = candle3.high;
            fvg.bar_index = (int)iBarShift(_Symbol, timeframe, candle2.time);
            fvg.isValid = true;
            return fvg;
        }
    }
    return fvg;
}

//+------------------------------------------------------------------+
//| Get Last Significant Swing High                                  |
//+------------------------------------------------------------------+
PriceZone GetLastSignificantSwingHigh(ENUM_TIMEFRAMES timeframe, int lookback_range, int N, int shift_start) {
    PriceZone swing_high;
    MqlRates rates[];
    ArraySetAsSeries(rates, true);

    int rates_to_copy = shift_start + lookback_range + N + 1;
    if (CopyRates(_Symbol, timeframe, 0, rates_to_copy, rates) < rates_to_copy) {
        PrintFormat("Error copying rates for GetLastSignificantSwingHigh on %s: %d", EnumToString(timeframe), GetLastError());
        return swing_high;
    }

    for (int candidate_idx = shift_start + N; candidate_idx < shift_start + lookback_range + N; candidate_idx++) {
        if (candidate_idx >= ArraySize(rates) - N) {
            break;
        }

        bool is_swing_high = true;
        double candidate_high = rates[candidate_idx].high;

        for (int j = 1; j <= N; j++) {
            if (rates[candidate_idx + j].high >= candidate_high) {
                is_swing_high = false;
                break;
            }
        }
        if (!is_swing_high) continue;

        for (int j = 1; j <= N; j++) {
            if (rates[candidate_idx - j].high >= candidate_high) {
                is_swing_high = false;
                break;
            }
        }

        if (is_swing_high) {
            swing_high.high = candidate_high;
            swing_high.low = rates[candidate_idx].low;
            swing_high.bar_index = (int)iBarShift(_Symbol, timeframe, rates[candidate_idx].time);
            swing_high.isValid = true;
            return swing_high;
        }
    }
    return swing_high;
}

//+------------------------------------------------------------------+
//| Get Last Significant Swing Low                                   |
//+------------------------------------------------------------------+
PriceZone GetLastSignificantSwingLow(ENUM_TIMEFRAMES timeframe, int lookback_range, int N, int shift_start) {
    PriceZone swing_low;
    MqlRates rates[];
    ArraySetAsSeries(rates, true);

    int rates_to_copy = shift_start + lookback_range + N + 1;
    if (CopyRates(_Symbol, timeframe, 0, rates_to_copy, rates) < rates_to_copy) {
        PrintFormat("Error copying rates for GetLastSignificantSwingLow on %s: %d", EnumToString(timeframe), GetLastError());
        return swing_low;
    }

    for (int candidate_idx = shift_start + N; candidate_idx < shift_start + lookback_range + N; candidate_idx++) {
         if (candidate_idx >= ArraySize(rates) - N) {
            break;
        }

        bool is_swing_low = true;
        double candidate_low = rates[candidate_idx].low;

        for (int j = 1; j <= N; j++) {
            if (rates[candidate_idx + j].low <= candidate_low) {
                is_swing_low = false;
                break;
            }
        }
        if (!is_swing_low) continue;

        for (int j = 1; j <= N; j++) {
            if (rates[candidate_idx - j].low <= candidate_low) {
                is_swing_low = false;
                break;
            }
        }

        if (is_swing_low) {
            swing_low.low = candidate_low;
            swing_low.high = rates[candidate_idx].high;
            swing_low.bar_index = (int)iBarShift(_Symbol, timeframe, rates[candidate_idx].time);
            swing_low.isValid = true;
            return swing_low;
        }
    }
    return swing_low;
}

//+------------------------------------------------------------------+
//| Check for Bullish Break of Structure                             |
//+------------------------------------------------------------------+
bool CheckForBullishBOS(ENUM_TIMEFRAMES timeframe, const PriceZone &prev_swing_high, int confirmation_shift) {
    if (!prev_swing_high.isValid) {
        return false;
    }

    double current_close = iClose(_Symbol, timeframe, confirmation_shift);
    if (current_close == EMPTY_VALUE && GetLastError() != 0) { // FIX: Check for EMPTY_VALUE
        // double min_break_value = (BOS_CHoCH_MinBreakPoints == 0) ? 0 : BOS_CHoCH_MinBreakPoints * _Point; // This line was redundant
        PrintFormat("CheckForBullishBOS: Error getting close for %s, shift %d. Error: %d", EnumToString(timeframe), confirmation_shift, GetLastError());
        return false;
    }
    
    double min_break_value = (BOS_CHoCH_MinBreakPoints == 0) ? 0 : BOS_CHoCH_MinBreakPoints * _Point;
    if (current_close > prev_swing_high.high + min_break_value) {
        return true;
    }
    return false;
}

//+------------------------------------------------------------------+
//| Check for Bearish Break of Structure                             |
//+------------------------------------------------------------------+
bool CheckForBearishBOS(ENUM_TIMEFRAMES timeframe, const PriceZone &prev_swing_low, int confirmation_shift) {
    if (!prev_swing_low.isValid) {
        return false;
    }

    double current_close = iClose(_Symbol, timeframe, confirmation_shift);
     if (current_close == EMPTY_VALUE && GetLastError() != 0) { // FIX: Check for EMPTY_VALUE
        PrintFormat("CheckForBearishBOS: Error getting close for %s, shift %d. Error: %d", EnumToString(timeframe), confirmation_shift, GetLastError());
        return false;
    }
    
    double min_break_value = (BOS_CHoCH_MinBreakPoints == 0) ? 0 : BOS_CHoCH_MinBreakPoints * _Point;
    if (current_close < prev_swing_low.low - min_break_value) {
        return true;
    }
    return false;
}

//+------------------------------------------------------------------+
//| Check for Bullish Change of Character                            |
//+------------------------------------------------------------------+
bool IsBullishCHoCH(ENUM_TIMEFRAMES timeframe, int swing_lookback, int N_structural_bars, int confirmation_shift, PriceZone &choch_level_broken) {
    choch_level_broken.Reset();

    PriceZone lastLL = GetLastSignificantSwingLow(timeframe, swing_lookback, N_structural_bars, confirmation_shift + N_structural_bars +1);
    if (!lastLL.isValid) {
        PrintFormat("IsBullishCHoCH (%s): No valid lastLL found.", EnumToString(timeframe));
        return false;
    }

    PriceZone lh_before_ll = GetLastSignificantSwingHigh(timeframe, swing_lookback, N_structural_bars, lastLL.bar_index + 1);
    
    if (!lh_before_ll.isValid) {
        PrintFormat("IsBullishCHoCH (%s): No valid LH before LL at bar %d found.", EnumToString(timeframe), lastLL.bar_index);
        return false;
    }
    
    if (lh_before_ll.bar_index <= lastLL.bar_index) {
        // FIX: Added a more detailed message for this logical check
        PrintFormat("IsBullishCHoCH (%s): LH at bar %d is not structurally before LL at bar %d. Skipping.", EnumToString(timeframe), lh_before_ll.bar_index, lastLL.bar_index);
        return false;
    }

    double current_close = iClose(_Symbol, timeframe, confirmation_shift);
    if (current_close == EMPTY_VALUE && GetLastError() != 0) return false; // FIX: Check for EMPTY_VALUE
    
    double min_break_value = (BOS_CHoCH_MinBreakPoints == 0) ? 0 : BOS_CHoCH_MinBreakPoints * _Point;
    if (current_close > lh_before_ll.high + min_break_value) {
        choch_level_broken = lh_before_ll;
        return true;
    }
    return false;
}

//+------------------------------------------------------------------+
//| Check for Bearish Change of Character                            |
//+------------------------------------------------------------------+
bool IsBearishCHoCH(ENUM_TIMEFRAMES timeframe, int swing_lookback, int N_structural_bars, int confirmation_shift, PriceZone &choch_level_broken) {
    choch_level_broken.Reset();

    PriceZone lastHH = GetLastSignificantSwingHigh(timeframe, swing_lookback, N_structural_bars, confirmation_shift + N_structural_bars + 1);
    if (!lastHH.isValid) {
        PrintFormat("IsBearishCHoCH (%s): No valid lastHH found.", EnumToString(timeframe));
        return false;
    }

    PriceZone hl_before_hh = GetLastSignificantSwingLow(timeframe, swing_lookback, N_structural_bars, lastHH.bar_index + 1);

    if (!hl_before_hh.isValid) {
        PrintFormat("IsBearishCHoCH (%s): No valid HL before HH at bar %d found.", EnumToString(timeframe), lastHH.bar_index);
        return false;
    }
    if (hl_before_hh.bar_index <= lastHH.bar_index) {
        // FIX: Added a more detailed message for this logical check
        PrintFormat("IsBearishCHoCH (%s): HL at bar %d is not structurally before HH at bar %d. Skipping.", EnumToString(timeframe), hl_before_hh.bar_index, lastHH.bar_index);
        return false;
    }

    double current_close = iClose(_Symbol, timeframe, confirmation_shift);
    if (current_close == EMPTY_VALUE && GetLastError() != 0) return false; // FIX: Check for EMPTY_VALUE
    
    double min_break_value = (BOS_CHoCH_MinBreakPoints == 0) ? 0 : BOS_CHoCH_MinBreakPoints * _Point;
    if (current_close < hl_before_hh.low - min_break_value) {
        choch_level_broken = hl_before_hh;
        return true;
    }
    return false;
}

//+------------------------------------------------------------------+
//| Check and Get Bullish Liquidity Sweep                            |
//+------------------------------------------------------------------+
bool CheckAndGetBullishLiquiditySweep(ENUM_TIMEFRAMES timeframe, const PriceZone &prev_swing_low,
                                      double min_spike_points, int max_close_back_candles,
                                      PriceZone &sweep_candle_info, int check_bar_shift) {
    sweep_candle_info.Reset();
    if (!prev_swing_low.isValid) return false;

    MqlRates candidate_rates[];
    int total_candles_needed = check_bar_shift + max_close_back_candles;
    if(CopyRates(_Symbol, timeframe, 0, total_candles_needed, candidate_rates) < total_candles_needed) return false;
    ArraySetAsSeries(candidate_rates, true);

    double sweep_low_price = candidate_rates[check_bar_shift].low;
    double actual_spike_points = (prev_swing_low.low - sweep_low_price) / _Point;

    if (sweep_low_price < prev_swing_low.low && (min_spike_points == 0 || actual_spike_points >= min_spike_points)) {
        for (int k = 0; k < max_close_back_candles; k++) {
            int confirmation_candle_idx = check_bar_shift - k;
            if (confirmation_candle_idx < 0) break;

            if (candidate_rates[confirmation_candle_idx].close > prev_swing_low.low) {
                sweep_candle_info.high = candidate_rates[check_bar_shift].high;
                sweep_candle_info.low = candidate_rates[check_bar_shift].low;
                sweep_candle_info.bar_index = check_bar_shift;
                sweep_candle_info.isValid = true;
                return true;
            }
        }
    }
    return false;
}

//+------------------------------------------------------------------+
//| Check and Get Bearish Liquidity Sweep                            |
//+------------------------------------------------------------------+
bool CheckAndGetBearishLiquiditySweep(ENUM_TIMEFRAMES timeframe, const PriceZone &prev_swing_high,
                                      double min_spike_points, int max_close_back_candles,
                                      PriceZone &sweep_candle_info, int check_bar_shift) {
    sweep_candle_info.Reset();
    if (!prev_swing_high.isValid) return false;

    MqlRates candidate_rates[];
    int total_candles_needed = check_bar_shift + max_close_back_candles;
    if(CopyRates(_Symbol, timeframe, 0, total_candles_needed, candidate_rates) < total_candles_needed) return false;
    ArraySetAsSeries(candidate_rates, true);

    double sweep_high_price = candidate_rates[check_bar_shift].high;
    double actual_spike_points = (sweep_high_price - prev_swing_high.high) / _Point;

    if (sweep_high_price > prev_swing_high.high && (min_spike_points == 0 || actual_spike_points >= min_spike_points)) {
        for (int k = 0; k < max_close_back_candles; k++) {
            int confirmation_candle_idx = check_bar_shift - k;
            if (confirmation_candle_idx < 0) break;

            if (candidate_rates[confirmation_candle_idx].close < prev_swing_high.high) {
                sweep_candle_info.high = candidate_rates[check_bar_shift].high;
                sweep_candle_info.low = candidate_rates[check_bar_shift].low;
                sweep_candle_info.bar_index = check_bar_shift;
                sweep_candle_info.isValid = true;
                return true;
            }
        }
    }
    return false;
}
//+------------------------------------------------------------------+
//| Find Swing Low                                                   |
//+------------------------------------------------------------------+
int FindSwingLow(ENUM_TIMEFRAMES timeframe, int lookback) {
   for (int i = 2; i < lookback; i++) {
     if (iLow(_Symbol, timeframe, i) < iLow(_Symbol, timeframe, i-1) && 
         iLow(_Symbol, timeframe, i) < iLow(_Symbol, timeframe, i+1)) {
         return i;
     }
   }
   return -1;
}

//+------------------------------------------------------------------+
//| Find Swing High                                                  |
//+------------------------------------------------------------------+
int FindSwingHigh(ENUM_TIMEFRAMES timeframe, int lookback) {
   for (int i = 2; i < lookback; i++) {
     if (iHigh(_Symbol, timeframe, i) > iHigh(_Symbol, timeframe, i-1) && 
         iHigh(_Symbol, timeframe, i) > iHigh(_Symbol, timeframe, i+1)) {
         return i;
     }
   }
   return -1;
}

//+------------------------------------------------------------------+
//| Update Market Analysis                                           |
//+------------------------------------------------------------------+
void UpdateMarketAnalysis() {
    // Multi-timeframe bias analysis
    ENUM_BIAS etfBias = AnalyzeTimeframeBias(PERIOD_CURRENT);
    ENUM_BIAS htf1Bias = AnalyzeTimeframeBias(HTF_Primary);
    ENUM_BIAS htf2Bias = AnalyzeTimeframeBias(HTF_Secondary);
    
    // Determine market structure
    marketStructure = DetermineMarketStructure();
    
    // Calculate composite bias with weighting
    double biasScore = 0;
    biasScore += (int)etfBias * 1.0;      // ETF weight: 1.0
    biasScore += (int)htf1Bias * 1.5;      // HTF1 weight: 1.5
    biasScore += (int)htf2Bias * 2.0;      // HTF2 weight: 2.0
    
    // Determine final bias
    if(biasScore >= 3.0) {
        currentBias = BIAS_STRONG_BULLISH;
    } else if(biasScore >= 1.5) {
        currentBias = BIAS_BULLISH;
    } else if(biasScore <= -3.0) {
        currentBias = BIAS_STRONG_BEARISH;
    } else if(biasScore <= -1.5) {
        currentBias = BIAS_BEARISH;
    } else {
        currentBias = BIAS_NEUTRAL;
    }
    
    // Log market state
    if(MQLInfoInteger(MQL_DEBUG)) {
        PrintFormat("Market Analysis: Bias=%s, Structure=%s, Score=%.2f",
                    BiasToString(currentBias),
                    StructureToString(marketStructure),
                    biasScore);
    }
}

//+------------------------------------------------------------------+
//| Analyze Timeframe Bias                                           |
//+------------------------------------------------------------------+
ENUM_BIAS AnalyzeTimeframeBias(ENUM_TIMEFRAMES timeframe) {
    int bullishFactors = 0;
    int bearishFactors = 0;
    
    // 1. Moving Average Analysis
    double ma50 = iMA(_Symbol, timeframe, 50, 0, MODE_EMA, PRICE_CLOSE); // FIX: Added shift = 0
    double ma200 = iMA(_Symbol, timeframe, 200, 0, MODE_EMA, PRICE_CLOSE); // FIX: Added shift = 0
    double close = iClose(_Symbol, timeframe, 0);
    
    // FIX: Add checks for EMPTY_VALUE return from iMA and iClose
    if (ma50 == EMPTY_VALUE || ma200 == EMPTY_VALUE || close == EMPTY_VALUE) {
        PrintFormat("AnalyzeTimeframeBias: Error getting MA or Close prices for %s. Error: %d", EnumToString(timeframe), GetLastError());
        return BIAS_NEUTRAL; // Cannot determine bias if data not available
    }

    if(ma50 > ma200 && close > ma50) bullishFactors += 2;
    else if(ma50 < ma200 && close < ma50) bearishFactors += 2;
    
    // 2. Market Structure (BOS/CHoCH)
    PriceZone lastHigh = GetLastSignificantSwingHigh(timeframe, SwingLookback, 3);
    PriceZone lastLow = GetLastSignificantSwingLow(timeframe, SwingLookback, 3);
    
    if(CheckForBullishBOS(timeframe, lastHigh)) bullishFactors += 3;
    if(CheckForBearishBOS(timeframe, lastLow)) bearishFactors += 3;
    
    // 3. Volume Analysis
    double avgVolume = GetAverageVolume(timeframe, 20);
    long currentVolume = iVolume(_Symbol, timeframe, 0); // FIX: iVolume returns long
    
    // FIX: Check for valid volume
    if (currentVolume == -1 && GetLastError() != 0) { // -1 is typical error for iVolume
         PrintFormat("AnalyzeTimeframeBias: Error getting current volume for %s. Error: %d", EnumToString(timeframe), GetLastError());
    } else if (avgVolume > 0 && currentVolume > avgVolume * 1.5) {
        // FIX: Check iOpen and iClose for valid values
        double open_price = iOpen(_Symbol, timeframe, 0);
        double close_price = iClose(_Symbol, timeframe, 0);

        if (open_price != EMPTY_VALUE && close_price != EMPTY_VALUE) {
            if(close_price > open_price) bullishFactors++;
            else bearishFactors++;
        }
    }
    
    // 4. SMC Zones presence
    int bullishZones = CountValidZones(zoneManager.bullishOBs) + CountValidZones(zoneManager.bullishFVGs);
    int bearishZones = CountValidZones(zoneManager.bearishOBs) + CountValidZones(zoneManager.bearishFVGs);
    
    if(bullishZones > bearishZones) bullishFactors++;
    else if(bearishZones > bullishZones) bearishFactors++;
    
    // Determine bias
    if(bullishFactors >= bearishFactors + 3) return BIAS_STRONG_BULLISH;
    else if(bullishFactors > bearishFactors) return BIAS_BULLISH;
    else if(bearishFactors >= bullishFactors + 3) return BIAS_STRONG_BEARISH;
    else if(bearishFactors > bullishFactors) return BIAS_BEARISH;
    else return BIAS_NEUTRAL;
}

//+------------------------------------------------------------------+
//| Determine Market Structure                                       |
//+------------------------------------------------------------------+
ENUM_MARKET_STRUCTURE DetermineMarketStructure() {
    // Calculate ATR for volatility
    double atr = iATR(_Symbol, PERIOD_CURRENT, 14); // FIX: Added shift = 0
    double atrMA = iMA(_Symbol, PERIOD_CURRENT, 50, 0, MODE_SMA, PRICE_TYPICAL); // FIX: Added shift = 0
    
    // FIX: Check for EMPTY_VALUE from indicators
    if (atr == EMPTY_VALUE || atrMA == EMPTY_VALUE) {
        PrintFormat("DetermineMarketStructure: Error getting ATR or ATR MA. Error: %d", GetLastError());
        return STRUCTURE_RANGING; // Fallback
    }

    double volatilityRatio = atr / (atrMA * _Point);
    // FIX: Handle division by zero for atrMA
    if (atrMA * _Point == 0) volatilityRatio = 0; 
    
    // Check for trending conditions
    int adxHandle = iADX(_Symbol, PERIOD_CURRENT, 14);
    // FIX: Check for INVALID_HANDLE for ADX
    if (adxHandle == INVALID_HANDLE) {
        PrintFormat("Failed to create ADX handle. Error: %d", GetLastError());
        return STRUCTURE_RANGING;
    }

    double adx[1], plusDI[1], minusDI[1]; // FIX: Declare as arrays with size [1]
    ArraySetAsSeries(adx, true);
    ArraySetAsSeries(plusDI, true);
    ArraySetAsSeries(minusDI, true);
    
    // FIX: Use CopyBuffer correctly and check return values
    if(CopyBuffer(adxHandle, 0, 0, 1, adx) > 0 &&
       CopyBuffer(adxHandle, 1, 0, 1, plusDI) > 0 &&
       CopyBuffer(adxHandle, 2, 0, 1, minusDI) > 0) {
        
        // FIX: Release indicator handle after use
        IndicatorRelease(adxHandle);
        
        if(volatilityRatio > 2.0) {
            return STRUCTURE_VOLATILE;
        } else if(adx[0] > 25) {
            if(plusDI[0] > minusDI[0]) return STRUCTURE_TRENDING_UP;
            else return STRUCTURE_TRENDING_DOWN;
        } else if(adx[0] < 20) {
            if(volatilityRatio < 0.5) return STRUCTURE_CONSOLIDATING;
            else return STRUCTURE_RANGING;
        }
    }
    
    // FIX: Ensure IndicatorRelease is called even if CopyBuffer fails
    IndicatorRelease(adxHandle);
    return STRUCTURE_RANGING;
}

//+------------------------------------------------------------------+
//| Look for Trade Setups                                            |
//+------------------------------------------------------------------+
void LookForTradeSetups() {
    // Collect all relevant zones
    CollectAndValidateZones();
    
    // Score each potential setup
    double buyScore = 0, sellScore = 0;
    
    // Check for buy setups
    if(currentBias >= BIAS_BULLISH && TradeBullish) {
        buyScore = ScoreBuySetup();
    }
    
    // Check for sell setups
    if(currentBias <= BIAS_BEARISH && TradeBearish) {
        sellScore = ScoreSellSetup();
    }
    
    // Execute the best setup
    double minScoreThreshold = 7.0; // Minimum score to take trade
    
    if(buyScore >= minScoreThreshold && buyScore > sellScore) {
        ExecuteEnhancedBuySetup(buyScore);
    } else if(sellScore >= minScoreThreshold) {
        ExecuteEnhancedSellSetup(sellScore);
    }
}

//+------------------------------------------------------------------+
//| Score Buy Setup                                                  |
//+------------------------------------------------------------------+
double ScoreBuySetup() {
    double score = 0;
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    
    // 1. Bias alignment (0-3 points)
    if(currentBias == BIAS_STRONG_BULLISH) score += 3;
    else if(currentBias == BIAS_BULLISH) score += 2;
    
    // 2. Order Block analysis (0-3 points)
    PriceZone nearestBullishOB = zoneManager.FindNearestZone(zoneManager.bullishOBs, currentPrice);
    if(nearestBullishOB.isValid) {
        if(IsPriceInZone(currentPrice, nearestBullishOB)) {
            score += 3;
            if(nearestBullishOB.touchCount >= OB_MinTouchesBeforeMitigation) {
                score += 1; // Bonus for tested OB
            }
        } else if(GetZoneDistance(currentPrice, nearestBullishOB) < 50 * _Point) {
            score += 1;
        }
    }
    
    // 3. FVG analysis (0-2 points)
    PriceZone nearestBullishFVG = zoneManager.FindNearestZone(zoneManager.bullishFVGs, currentPrice);
    if(nearestBullishFVG.isValid && IsPriceInZone(currentPrice, nearestBullishFVG)) {
        double mitigationPercent = GetFVGMitigationPercent(currentPrice, nearestBullishFVG);
        if(mitigationPercent >= FVG_MinMitigationPercent) {
            score += 2;
        }
    }
    
    // 4. Liquidity sweep (0-2 points)
    if(CheckRecentBullishSweep()) {
        score += 2;
    }
    
    // 5. Market structure (0-2 points)
    if(CheckBullishMarketStructure()) {
        score += 2;
    }
    
    // 6. Momentum confirmation (0-1 point)
    if(CheckBullishMomentum()) {
        score += 1;
    }
    
    // 7. Multi-timeframe confluence (0-2 points)
    if(CheckHTFBullishConfluence()) {
        score += 2;
    }
    
    return score;
}

//+------------------------------------------------------------------+
//| Score Sell Setup                                                 |
//+------------------------------------------------------------------+
double ScoreSellSetup() {
    double score = 0;
    double currentPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // 1. Bias alignment (0-3 points)
    if(currentBias == BIAS_STRONG_BEARISH) score += 3;
    else if(currentBias == BIAS_BEARISH) score += 2;
    
    // 2. Order Block analysis (0-3 points)
    PriceZone nearestBearishOB = zoneManager.FindNearestZone(zoneManager.bearishOBs, currentPrice);
    if(nearestBearishOB.isValid) {
        if(IsPriceInZone(currentPrice, nearestBearishOB)) {
            score += 3;
            if(nearestBearishOB.touchCount >= OB_MinTouchesBeforeMitigation) {
                score += 1;
            }
        } else if(GetZoneDistance(currentPrice, nearestBearishOB) < 50 * _Point) {
            score += 1;
        }
    }
    
    // 3. FVG analysis (0-2 points)
    PriceZone nearestBearishFVG = zoneManager.FindNearestZone(zoneManager.bearishFVGs, currentPrice);
    if(nearestBearishFVG.isValid && IsPriceInZone(currentPrice, nearestBearishFVG)) {
        double mitigationPercent = GetFVGMitigationPercent(currentPrice, nearestBearishFVG);
        if(mitigationPercent >= FVG_MinMitigationPercent) {
            score += 2;
        }
    }
    
    // 4. Liquidity sweep (0-2 points)
    if(CheckRecentBearishSweep()) {
        score += 2;
    }
    
    // 5. Market structure (0-2 points)
    if(CheckBearishMarketStructure()) {
        score += 2;
    }
    
    // 6. Momentum confirmation (0-1 point)
    if(CheckBearishMomentum()) {
        score += 1;
    }
    
    // 7. Multi-timeframe confluence (0-2 points)
    if(CheckHTFBearishConfluence()) {
        score += 2;
    }
    
    return score;
}

//+------------------------------------------------------------------+
//| Execute Enhanced Buy Setup                                       |
//+------------------------------------------------------------------+
void ExecuteEnhancedBuySetup(double setupScore) {
    double entryPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double stopLoss = 0;
    double takeProfit1 = 0;
    double takeProfit2 = 0;
    
    // Determine optimal stop loss from multiple factors
    stopLoss = CalculateOptimalStopLoss(ORDER_TYPE_BUY);
    
    if(stopLoss <= 0 || stopLoss >= entryPrice) {
        Print("Invalid stop loss calculated for buy setup");
        return;
    }
    
    // Calculate position size with enhanced risk management
    double lotSize = CalculateEnhancedLotSize(entryPrice - stopLoss, setupScore);
    
    if(lotSize <= 0) {
        Print("Invalid lot size calculated");
        return;
    }
    
    // Calculate take profit levels
    double riskDistance = entryPrice - stopLoss;
    takeProfit1 = entryPrice + (riskDistance * TP1_RRRatio);
    takeProfit2 = entryPrice + (riskDistance * TP2_RRRatio);
    
    // Prepare trade comment with setup details
    string comment = StringFormat("SMC_BUY_Score:%.1f", setupScore);
    
    // Execute trade with error handling
    trade.SetExpertMagicNumber(GetDynamicMagicNumber(ORDER_TYPE_BUY));
    
    if(trade.Buy(lotSize, _Symbol, entryPrice, stopLoss, takeProfit2, comment)) {
        // Store trade information for management
        SaveTradeInfo(trade.ResultOrder(), setupScore, takeProfit1, takeProfit2);
        
        dailyTradeCount++;
        
        PrintFormat("✓ BUY Trade Executed: Entry=%.5f, SL=%.5f, TP1=%.5f, TP2=%.5f, Score=%.1f",
                    entryPrice, stopLoss, takeProfit1, takeProfit2, setupScore);
                    
        // Send notification if enabled
        SendTradeNotification("BUY", entryPrice, stopLoss, takeProfit2, lotSize, setupScore);
    } else {
        PrintFormat("✗ BUY Trade Failed: %s (Error %d)", 
                    trade.ResultComment(), trade.ResultRetcode());
    }
}

//+------------------------------------------------------------------+
//| Execute Enhanced Sell Setup                                      |
//+------------------------------------------------------------------+
void ExecuteEnhancedSellSetup(double setupScore) {
    double entryPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double stopLoss = 0;
    double takeProfit1 = 0;
    double takeProfit2 = 0;
    
    stopLoss = CalculateOptimalStopLoss(ORDER_TYPE_SELL);
    
    if(stopLoss <= 0 || stopLoss <= entryPrice) {
        Print("Invalid stop loss calculated for sell setup");
        return;
    }
    
    double lotSize = CalculateEnhancedLotSize(stopLoss - entryPrice, setupScore);
    
    if(lotSize <= 0) {
        Print("Invalid lot size calculated");
        return;
    }
    
    double riskDistance = stopLoss - entryPrice;
    takeProfit1 = entryPrice - (riskDistance * TP1_RRRatio);
    takeProfit2 = entryPrice - (riskDistance * TP2_RRRatio);
    
    string comment = StringFormat("SMC_SELL_Score:%.1f", setupScore);
    
    trade.SetExpertMagicNumber(GetDynamicMagicNumber(ORDER_TYPE_SELL));
    
    if(trade.Sell(lotSize, _Symbol, entryPrice, stopLoss, takeProfit2, comment)) {
        SaveTradeInfo(trade.ResultOrder(), setupScore, takeProfit1, takeProfit2);
        dailyTradeCount++;
        
        PrintFormat("✓ SELL Trade Executed: Entry=%.5f, SL=%.5f, TP1=%.5f, TP2=%.5f, Score=%.1f",
                    entryPrice, stopLoss, takeProfit1, takeProfit2, setupScore);
                    
        SendTradeNotification("SELL", entryPrice, stopLoss, takeProfit2, lotSize, setupScore);
    } else {
        PrintFormat("✗ SELL Trade Failed: %s (Error %d)", 
                    trade.ResultComment(), trade.ResultRetcode());
    }
}
//+------------------------------------------------------------------+
//| Manage Partial Take Profit                                       |
//+------------------------------------------------------------------+
void ManagePartialTP(CPositionInfo &position) {
    if(!UsePartialTakeProfit) return;
    
    // Check if partial TP already taken
    string posComment = position.Comment();
    if(StringFind(posComment, "partial") >= 0) return;
    
    double tp1 = GetTradeTP1(position.Ticket());
    if(tp1 == 0) return;
    
    double currentPrice = position.PriceCurrent();
    bool shouldPartialClose = false;
    
    if(position.PositionType() == POSITION_TYPE_BUY) {
        shouldPartialClose = (currentPrice >= tp1);
    } else {
        shouldPartialClose = (currentPrice <= tp1);
    }
    
    if(shouldPartialClose) {
        double partialLots = NormalizeLotSize(position.Volume() * PartialTPPercent / 100.0);
        
        if(partialLots > 0 && trade.PositionClosePartial(position.Ticket(), partialLots)) {
            Print("✓ Partial TP executed: ", partialLots, " lots at TP1");
            UpdateTradeComment(position.Ticket(), "partial");
        }
    }
}

void ManageTrailingStop(CPositionInfo &position) {
    if(!UseTrailingStop) return;
    
    double positionOpenPrice = position.PriceOpen();
    double positionSL = position.StopLoss();
    double currentPrice = position.PriceCurrent();
    
    double initialRisk = MathAbs(positionOpenPrice - positionSL);
    double trailTriggerDistance = initialRisk * TrailStartRR;
    double trailDistance = initialRisk * TrailDistanceRR;
    
    bool shouldTrail = false;
    double newSL = 0;
    
    if(position.PositionType() == POSITION_TYPE_BUY) {
        if(currentPrice >= positionOpenPrice + trailTriggerDistance) {
            double proposedSL = currentPrice - trailDistance;
            if(proposedSL > positionSL && proposedSL > positionOpenPrice) {
                shouldTrail = true;
                newSL = proposedSL;
            }
        }
    } else {
        if(currentPrice <= positionOpenPrice - trailTriggerDistance) {
            double proposedSL = currentPrice + trailDistance;
            if(proposedSL < positionSL && proposedSL < positionOpenPrice) {
                shouldTrail = true;
                newSL = proposedSL;
            }
        }
    }
    
    if(shouldTrail && newSL != 0) {
        if(trade.PositionModify(position.Ticket(), newSL, position.TakeProfit())) {
            Print("✓ Trailing stop updated: Ticket #", position.Ticket(), " New SL: ", newSL);
        }
    }
}

//+------------------------------------------------------------------+
//| Helper Functions                                                 |
//+------------------------------------------------------------------+
bool IsPriceInZone(double price, const PriceZone &zone) {
    return (price >= zone.low && price <= zone.high);
}

double GetZoneDistance(double price, const PriceZone &zone) {
    if(price > zone.high) return price - zone.high;
    if(price < zone.low) return zone.low - price;
    return 0; // Price is in zone
}

double GetFVGMitigationPercent(double price, const PriceZone &fvg) {
    double fvgRange = fvg.high - fvg.low;
    if(fvgRange <= 0) return 0;
    
    if(price >= fvg.high) return 100;
    if(price <= fvg.low) return 0;
    
    return ((price - fvg.low) / fvgRange) * 100;
}

int CountValidZones(const PriceZone &zones[]) {
    int count = 0;
    for(int i = 0; i < ArraySize(zones); i++) {
        if(zones[i].isValid) count++;
    }
    return count;
}

string BiasToString(ENUM_BIAS bias) {
    switch(bias) {
        case BIAS_STRONG_BULLISH: return "Strong Bullish";
        case BIAS_BULLISH: return "Bullish";
        case BIAS_NEUTRAL: return "Neutral";
        case BIAS_BEARISH: return "Bearish";
        case BIAS_STRONG_BEARISH: return "Strong Bearish";
        default: return "Unknown";
    }
}

string StructureToString(ENUM_MARKET_STRUCTURE structure) {
    switch(structure) {
        case STRUCTURE_TRENDING_UP: return "Trending Up";
        case STRUCTURE_TRENDING_DOWN: return "Trending Down";
        case STRUCTURE_RANGING: return "Ranging";
        case STRUCTURE_CONSOLIDATING: return "Consolidating";
        case STRUCTURE_VOLATILE: return "Volatile";
        default: return "Unknown";
    }
}

//+------------------------------------------------------------------+
//| Performance and Risk Management                                  |
//+------------------------------------------------------------------+
void UpdatePerformanceStats() {
    // Update stats every hour
    if(TimeCurrent() - stats.lastUpdate < 3600) return;
    
    stats.totalTrades = 0;
    stats.winningTrades = 0;
    stats.losingTrades = 0;
    stats.totalProfit = 0;
    stats.totalLoss = 0;
    
    // Analyze trade history
    HistorySelect(TimeCurrent() - 30 * 24 * 3600, TimeCurrent()); // Last 30 days
    
    for(int i = 0; i < HistoryDealsTotal(); i++) {
        ulong ticket = HistoryDealGetTicket(i);
        if(ticket == 0) continue;
        
        if(HistoryDealGetString(ticket, DEAL_SYMBOL) != _Symbol) continue;
        if(HistoryDealGetInteger(ticket, DEAL_ENTRY) != DEAL_ENTRY_OUT) continue;
        
        double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
        double commission = HistoryDealGetDouble(ticket, DEAL_COMMISSION);
        double swap = HistoryDealGetDouble(ticket, DEAL_SWAP);
        double netProfit = profit + commission + swap;
        
        if(netProfit > 0) {
            stats.winningTrades++;
            stats.totalProfit += netProfit;
        } else if(netProfit < 0) {
            stats.losingTrades++;
            stats.totalLoss += MathAbs(netProfit);
        }
        stats.totalTrades++;
    }
    
    // Calculate derived statistics
    if(stats.totalTrades > 0) {
        stats.winRate = (double)stats.winningTrades / stats.totalTrades * 100;
        stats.averageWin = (stats.winningTrades > 0) ? stats.totalProfit / stats.winningTrades : 0;
        stats.averageLoss = (stats.losingTrades > 0) ? stats.totalLoss / stats.losingTrades : 0;
        stats.profitFactor = (stats.totalLoss > 0) ? stats.totalProfit / stats.totalLoss : 0;
    }
    
    stats.lastUpdate = TimeCurrent();
    
    // Save stats
    SavePersistentData();
}

// FIX: Added missing function definitions based on typical EA structure
// These functions were declared but not defined in your original snippet.
// They are essential for the EA to work correctly.
// I will provide basic implementations for them. You might need to refine them
// based on your specific SMC logic.

//+------------------------------------------------------------------+
//| Manage Open Positions                                            |
//+------------------------------------------------------------------+
void ManageOpenPositions() {
    for (int i = PositionsTotal() - 1; i >= 0; i--) {
        if (positionInfo.SelectByIndex(i)) {
            // Check if this position belongs to our EA
            if (positionInfo.Symbol() == _Symbol && positionInfo.Magic() == ea_magic_number) {
                ManageBreakEven(positionInfo);
                ManagePartialTP(positionInfo);
                ManageTrailingStop(positionInfo);
                CheckExitSignals(positionInfo);
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Calculate Optimal Stop Loss (Basic Implementation)               |
//+------------------------------------------------------------------+
double CalculateOptimalStopLoss(ENUM_ORDER_TYPE orderType) {
    // This is a placeholder. You need to implement your SMC-based SL logic here.
    // For now, it will use a fixed distance based on MinStopDistancePoints
    // or previous swing high/low if available.

    double currentPrice = (orderType == ORDER_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double sl_price = 0;
    double min_sl_distance = MinStopDistancePoints * _Point;

    if (orderType == ORDER_TYPE_BUY) {
        PriceZone lastSwingLow = GetLastSignificantSwingLow(PERIOD_CURRENT, SwingLookback, StructuralSwingMinBars);
        if (lastSwingLow.isValid && currentPrice - lastSwingLow.low > min_sl_distance) {
            sl_price = lastSwingLow.low - SL_BufferPoints * _Point;
        } else {
            // Fallback to fixed pips if no suitable swing low found
            sl_price = currentPrice - (min_sl_distance + SL_BufferPoints * _Point);
        }
    } else { // SELL
        PriceZone lastSwingHigh = GetLastSignificantSwingHigh(PERIOD_CURRENT, SwingLookback, StructuralSwingMinBars);
        if (lastSwingHigh.isValid && lastSwingHigh.high - currentPrice > min_sl_distance) {
            sl_price = lastSwingHigh.high + SL_BufferPoints * _Point;
        } else {
            // Fallback to fixed pips if no suitable swing high found
            sl_price = currentPrice + (min_sl_distance + SL_BufferPoints * _Point);
        }
    }
    
    // Ensure SL is a valid price (e.g., above 0 and not too close to current price)
    // You might need to add more sophisticated checks here, like SymbolInfo.CheckStopLoss() if available
    // and adjusting to broker's freeze level.
    if (sl_price <= 0 || (orderType == ORDER_TYPE_BUY && sl_price >= currentPrice) || (orderType == ORDER_TYPE_SELL && sl_price <= currentPrice)) {
        Print("Calculated SL is invalid or too close. Using default minimum SL.");
        if (orderType == ORDER_TYPE_BUY) {
            sl_price = currentPrice - (MinStopDistancePoints * _Point + SL_BufferPoints * _Point);
        } else {
            sl_price = currentPrice + (MinStopDistancePoints * _Point + SL_BufferPoints * _Point);
        }
    }
    
    return NormalizeDouble(sl_price, symbolInfo.Digits());
}

//+------------------------------------------------------------------+
//| Calculate Enhanced Lot Size (Basic Implementation)               |
//+------------------------------------------------------------------+
double CalculateEnhancedLotSize(double stopDistance, double setupScore) {
    if (stopDistance <= 0) {
        Print("CalculateEnhancedLotSize: Stop distance is zero or negative.");
        return 0;
    }

    double accountBalance = accountInfo.Balance();
    if (accountBalance <= 0) {
        Print("CalculateEnhancedLotSize: Account balance is zero or negative.");
        return 0;
    }

    double riskAmount = accountBalance * (RiskPercentage / 100.0); // Risk in deposit currency
    double pointValue = symbolInfo.TickValue(); // Value of one point in deposit currency for one lot
    
    if (pointValue <= 0) {
        Print("CalculateEnhancedLotSize: Point value is zero or negative.");
        return 0;
    }

    // Number of points in stopDistance
    double stopLossPoints = stopDistance / _Point;

    // Lot size based on risk and stop loss
    double lots = riskAmount / (stopLossPoints * pointValue);

    // Apply performance multiplier (optional, but declared)
    // double performanceMultiplier = GetPerformanceMultiplier(); 
    // lots *= performanceMultiplier;

    return NormalizeLotSize(lots);
}

//+------------------------------------------------------------------+
//| Get Performance Multiplier (Placeholder)                         |
//+------------------------------------------------------------------+
double GetPerformanceMultiplier() {
    // This function can be used to dynamically adjust lot size based on EA's recent performance.
    // For example, increase lot size during winning streaks, decrease during drawdowns.
    // Currently, it just returns 1.0, meaning no multiplier effect.
    return 1.0; 
}


//+------------------------------------------------------------------+
//| Manage Break Even (Basic Implementation)                         |
//+------------------------------------------------------------------+
void ManageBreakEven(CPositionInfo &position) {
    if(!UseBreakEven) return;
    
    double currentPrice = position.PriceCurrent();
    double positionOpenPrice = position.PriceOpen();
    double currentSL = position.StopLoss();
    double riskDistance = MathAbs(positionOpenPrice - currentSL);

    // Calculate BE trigger price
    double beTriggerPrice;
    if (position.PositionType() == POSITION_TYPE_BUY) {
        beTriggerPrice = positionOpenPrice + riskDistance * BE_Trigger_RR;
        if (currentPrice >= beTriggerPrice && currentSL < positionOpenPrice + BE_Plus_Pips * _Point) { // Only move if current SL is worse
            double newSL = positionOpenPrice + BE_Plus_Pips * _Point;
            if (trade.PositionModify(position.Ticket(), NormalizeDouble(newSL, symbolInfo.Digits()), position.TakeProfit())) {
                PrintFormat("✓ Position #%d moved to BE. New SL: %.5f", position.Ticket(), newSL);
            } else {
                PrintFormat("✗ Failed to move position #%d to BE: %s", position.Ticket(), trade.ResultComment());
            }
        }
    } else { // SELL position
        beTriggerPrice = positionOpenPrice - riskDistance * BE_Trigger_RR;
        if (currentPrice <= beTriggerPrice && currentSL > positionOpenPrice - BE_Plus_Pips * _Point) { // Only move if current SL is worse
            double newSL = positionOpenPrice - BE_Plus_Pips * _Point;
            if (trade.PositionModify(position.Ticket(), NormalizeDouble(newSL, symbolInfo.Digits()), position.TakeProfit())) {
                PrintFormat("✓ Position #%d moved to BE. New SL: %.5f", position.Ticket(), newSL);
            } else {
                PrintFormat("✗ Failed to move position #%d to BE: %s", position.Ticket(), trade.ResultComment());
            }
        }
    }
}

//+------------------------------------------------------------------+
//| Manage Partial Take Profit                                       |
//+------------------------------------------------------------------+
// Your original implementation of ManagePartialTP was already functional.
// I've kept it as is, just ensuring it's called from ManageOpenPositions.

//+------------------------------------------------------------------+
//| Manage Trailing Stop                                             |
//+------------------------------------------------------------------+
// Your original implementation of ManageTrailingStop was already functional.
// I've kept it as is, just ensuring it's called from ManageOpenPositions.

//+------------------------------------------------------------------+
//| Helper Functions (continued)                                     |
//+------------------------------------------------------------------+

// Normalize lot size to suit broker's requirements
double NormalizeLotSize(double lotSize) {
    double min_lot = symbolInfo.LotsMin();
    double max_lot = symbolInfo.LotsMax();
    double step_lot = symbolInfo.LotsStep();

    lotSize = MathMax(min_lot, lotSize); // Ensure it's at least min_lot
    lotSize = MathMin(max_lot, lotSize); // Ensure it's not more than max_lot
    
    // Normalize to lot step
    lotSize = MathRound(lotSize / step_lot) * step_lot;
    
    return NormalizeDouble(lotSize, 2); // Typically lots are normalized to 2 decimal places
}

void DeleteObjectsByPrefix(const string prefix) {
    long chart_id = ChartID();
    int total_objects = ObjectsTotal(chart_id, 0, -1); // Get total objects on current chart
    
    for(int i = total_objects - 1; i >= 0; i--) {
        string obj_name = ObjectName(chart_id, i, 0, -1);
        if(StringFind(obj_name, prefix) == 0) { // If object name starts with the prefix
            ObjectDelete(chart_id, obj_name);
        }
    }
}

void DrawOrderBlock(const PriceZone &zone, color ob_color, string ob_name_prefix, ENUM_TIMEFRAMES timeframe,
                    ENUM_LINE_STYLE style, int width, bool fill, int extend_bars) {
    string name = StringFormat("%s_%s_%d", ob_name_prefix, EnumToString(timeframe), zone.bar_index);
    
    // Check if object already exists to avoid redrawing multiple times per bar
    if (ObjectFind(0, name) != -1) return;

    datetime time1 = iTime(_Symbol, timeframe, zone.bar_index);
    // Extend to the right by 'extend_bars' from the current bar's time
    datetime time2 = iTime(_Symbol, timeframe, 0); // Current bar's time to extend to
    
    if (time1 == 0 || time2 == 0) return; // Error getting time

    // Create a rectangle object
    if (!ObjectCreate(0, name, OBJ_RECTANGLE, 0, time1, zone.high, time2, zone.low)) {
        PrintFormat("Error creating OB rectangle object %s. Error: %d", name, GetLastError());
        return;
    }
    
    ObjectSetInteger(0, name, OBJPROP_COLOR, ob_color);
    ObjectSetInteger(0, name, OBJPROP_STYLE, style);
    ObjectSetInteger(0, name, OBJPROP_WIDTH, width);
    ObjectSetInteger(0, name, OBJPROP_FILL, fill);
    ObjectSetInteger(0, name, OBJPROP_BACK, true); // Send to background
    ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false); // Make it non-selectable
    // ObjectSetInteger(0, name, OBJPROP_HIDDEN, true); // Hide from object list if desired, but for debugging keep false
    ObjectSetString(0, name, OBJPROP_TOOLTIP, StringFormat("OB H:%.5f L:%.5f", zone.high, zone.low));
    ObjectSetInteger(0, name, OBJPROP_TIMEFRAMES, timeframe); // Show only on this timeframe
    
    ChartRedraw();
}

void DrawFairValueGap(const PriceZone &zone, color fvg_color, string fvg_name_prefix, ENUM_TIMEFRAMES timeframe,
                      ENUM_LINE_STYLE style, int width, bool fill, int extend_bars) {
    string name = StringFormat("%s_%s_%d", fvg_name_prefix, EnumToString(timeframe), zone.bar_index);

    // Check if object already exists to avoid redrawing multiple times per bar
    if (ObjectFind(0, name) != -1) return;

    datetime time1 = iTime(_Symbol, timeframe, zone.bar_index);
    // Extend to the right by 'extend_bars' from the current bar's time
    datetime time2 = iTime(_Symbol, timeframe, 0); // Current bar's time to extend to

    if (time1 == 0 || time2 == 0) return; // Error getting time

    if (!ObjectCreate(0, name, OBJ_RECTANGLE, 0, time1, zone.high, time2, zone.low)) {
        PrintFormat("Error creating FVG rectangle object %s. Error: %d", name, GetLastError());
        return;
    }
    
    ObjectSetInteger(0, name, OBJPROP_COLOR, fvg_color);
    ObjectSetInteger(0, name, OBJPROP_STYLE, style);
    ObjectSetInteger(0, name, OBJPROP_WIDTH, width);
    ObjectSetInteger(0, name, OBJPROP_FILL, fill);
    ObjectSetInteger(0, name, OBJPROP_BACK, true);
    ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
    // ObjectSetInteger(0, name, OBJPROP_HIDDEN, true);
    ObjectSetString(0, name, OBJPROP_TOOLTIP, StringFormat("FVG H:%.5f L:%.5f", zone.high, zone.low));
    ObjectSetInteger(0, name, OBJPROP_TIMEFRAMES, timeframe);
    
    ChartRedraw();
}

void DrawLiquiditySweepMarker(ENUM_TIMEFRAMES timeframe, const PriceZone &sweep_candle_info, 
                              const PriceZone &swept_level_info, bool is_bullish_sweep, 
                              color sweep_color, int arrow_code) {
    string name = StringFormat("SMC_LS_%s_%d", is_bullish_sweep ? "Bullish" : "Bearish", sweep_candle_info.bar_index);
    
    if (ObjectFind(0, name) != -1) return;

    datetime time = iTime(_Symbol, timeframe, sweep_candle_info.bar_index);
    if (time == 0) return;

    double price = is_bullish_sweep ? sweep_candle_info.low : sweep_candle_info.high;

    if (!ObjectCreate(0, name, OBJ_ARROW, 0, time, price)) {
        PrintFormat("Error creating LS arrow object %s. Error: %d", name, GetLastError());
        return;
    }

    ObjectSetInteger(0, name, OBJPROP_ARROWCODE, arrow_code);
    ObjectSetInteger(0, name, OBJPROP_COLOR, sweep_color);
    ObjectSetInteger(0, name, OBJPROP_WIDTH, 1);
    ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
    ObjectSetInteger(0, name, OBJPROP_TIMEFRAMES, timeframe);
    ObjectSetString(0, name, OBJPROP_TOOLTIP, StringFormat("Liquidity Sweep at %.5f (Level: %.5f)", price, is_bullish_sweep ? swept_level_info.low : swept_level_info.high));
    
    ChartRedraw();
}


//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
    // Save all data
    SavePersistentData();
    
    // Clean up visual objects
    ObjectsDeleteAll(0, "SMC_");
    
    // Log shutdown
    Print("EA Shutdown. Reason: ", reason);
    Print("Final Stats - Trades: ", stats.totalTrades, 
          " Win Rate: ", DoubleToString(stats.winRate, 2), "%",
          " Profit Factor: ", DoubleToString(stats.profitFactor, 2));

}
